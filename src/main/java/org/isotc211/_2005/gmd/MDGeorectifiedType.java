//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2015.05.23 at 04:12:02 PM KST 
//


package org.isotc211._2005.gmd;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import org.isotc211._2005.gco.BooleanPropertyType;
import org.isotc211._2005.gco.CharacterStringPropertyType;
import org.isotc211._2005.gss.GMPointPropertyType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for MD_Georectified_Type complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="MD_Georectified_Type"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://www.isotc211.org/2005/gmd}MD_GridSpatialRepresentation_Type"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="checkPointAvailability" type="{http://www.isotc211.org/2005/gco}Boolean_PropertyType"/&gt;
 *         &lt;element name="checkPointDescription" type="{http://www.isotc211.org/2005/gco}CharacterString_PropertyType" minOccurs="0"/&gt;
 *         &lt;element name="cornerPoints" type="{http://www.isotc211.org/2005/gss}GM_Point_PropertyType" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="centerPoint" type="{http://www.isotc211.org/2005/gss}GM_Point_PropertyType" minOccurs="0"/&gt;
 *         &lt;element name="pointInPixel" type="{http://www.isotc211.org/2005/gmd}MD_PixelOrientationCode_PropertyType"/&gt;
 *         &lt;element name="transformationDimensionDescription" type="{http://www.isotc211.org/2005/gco}CharacterString_PropertyType" minOccurs="0"/&gt;
 *         &lt;element name="transformationDimensionMapping" type="{http://www.isotc211.org/2005/gco}CharacterString_PropertyType" maxOccurs="2" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "MD_Georectified_Type", propOrder = {
    "checkPointAvailability",
    "checkPointDescription",
    "cornerPoints",
    "centerPoint",
    "pointInPixel",
    "transformationDimensionDescription",
    "transformationDimensionMapping"
})
public class MDGeorectifiedType
    extends MDGridSpatialRepresentationType
    implements Cloneable, CopyTo, Equals, HashCode, ToString
{

    @XmlElement(required = true)
    protected BooleanPropertyType checkPointAvailability;
    protected CharacterStringPropertyType checkPointDescription;
    protected List<GMPointPropertyType> cornerPoints;
    protected GMPointPropertyType centerPoint;
    @XmlElement(required = true)
    protected MDPixelOrientationCodePropertyType pointInPixel;
    protected CharacterStringPropertyType transformationDimensionDescription;
    protected List<CharacterStringPropertyType> transformationDimensionMapping;

    /**
     * Gets the value of the checkPointAvailability property.
     * 
     * @return
     *     possible object is
     *     {@link BooleanPropertyType }
     *     
     */
    public BooleanPropertyType getCheckPointAvailability() {
        return checkPointAvailability;
    }

    /**
     * Sets the value of the checkPointAvailability property.
     * 
     * @param value
     *     allowed object is
     *     {@link BooleanPropertyType }
     *     
     */
    public void setCheckPointAvailability(BooleanPropertyType value) {
        this.checkPointAvailability = value;
    }

    /**
     * Gets the value of the checkPointDescription property.
     * 
     * @return
     *     possible object is
     *     {@link CharacterStringPropertyType }
     *     
     */
    public CharacterStringPropertyType getCheckPointDescription() {
        return checkPointDescription;
    }

    /**
     * Sets the value of the checkPointDescription property.
     * 
     * @param value
     *     allowed object is
     *     {@link CharacterStringPropertyType }
     *     
     */
    public void setCheckPointDescription(CharacterStringPropertyType value) {
        this.checkPointDescription = value;
    }

    /**
     * Gets the value of the cornerPoints property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the cornerPoints property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCornerPoints().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GMPointPropertyType }
     * 
     * 
     */
    public List<GMPointPropertyType> getCornerPoints() {
        if (cornerPoints == null) {
            cornerPoints = new ArrayList<GMPointPropertyType>();
        }
        return this.cornerPoints;
    }

    /**
     * Gets the value of the centerPoint property.
     * 
     * @return
     *     possible object is
     *     {@link GMPointPropertyType }
     *     
     */
    public GMPointPropertyType getCenterPoint() {
        return centerPoint;
    }

    /**
     * Sets the value of the centerPoint property.
     * 
     * @param value
     *     allowed object is
     *     {@link GMPointPropertyType }
     *     
     */
    public void setCenterPoint(GMPointPropertyType value) {
        this.centerPoint = value;
    }

    /**
     * Gets the value of the pointInPixel property.
     * 
     * @return
     *     possible object is
     *     {@link MDPixelOrientationCodePropertyType }
     *     
     */
    public MDPixelOrientationCodePropertyType getPointInPixel() {
        return pointInPixel;
    }

    /**
     * Sets the value of the pointInPixel property.
     * 
     * @param value
     *     allowed object is
     *     {@link MDPixelOrientationCodePropertyType }
     *     
     */
    public void setPointInPixel(MDPixelOrientationCodePropertyType value) {
        this.pointInPixel = value;
    }

    /**
     * Gets the value of the transformationDimensionDescription property.
     * 
     * @return
     *     possible object is
     *     {@link CharacterStringPropertyType }
     *     
     */
    public CharacterStringPropertyType getTransformationDimensionDescription() {
        return transformationDimensionDescription;
    }

    /**
     * Sets the value of the transformationDimensionDescription property.
     * 
     * @param value
     *     allowed object is
     *     {@link CharacterStringPropertyType }
     *     
     */
    public void setTransformationDimensionDescription(CharacterStringPropertyType value) {
        this.transformationDimensionDescription = value;
    }

    /**
     * Gets the value of the transformationDimensionMapping property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the transformationDimensionMapping property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTransformationDimensionMapping().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CharacterStringPropertyType }
     * 
     * 
     */
    public List<CharacterStringPropertyType> getTransformationDimensionMapping() {
        if (transformationDimensionMapping == null) {
            transformationDimensionMapping = new ArrayList<CharacterStringPropertyType>();
        }
        return this.transformationDimensionMapping;
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            BooleanPropertyType theCheckPointAvailability;
            theCheckPointAvailability = this.getCheckPointAvailability();
            strategy.appendField(locator, this, "checkPointAvailability", buffer, theCheckPointAvailability);
        }
        {
            CharacterStringPropertyType theCheckPointDescription;
            theCheckPointDescription = this.getCheckPointDescription();
            strategy.appendField(locator, this, "checkPointDescription", buffer, theCheckPointDescription);
        }
        {
            List<GMPointPropertyType> theCornerPoints;
            theCornerPoints = (((this.cornerPoints!= null)&&(!this.cornerPoints.isEmpty()))?this.getCornerPoints():null);
            strategy.appendField(locator, this, "cornerPoints", buffer, theCornerPoints);
        }
        {
            GMPointPropertyType theCenterPoint;
            theCenterPoint = this.getCenterPoint();
            strategy.appendField(locator, this, "centerPoint", buffer, theCenterPoint);
        }
        {
            MDPixelOrientationCodePropertyType thePointInPixel;
            thePointInPixel = this.getPointInPixel();
            strategy.appendField(locator, this, "pointInPixel", buffer, thePointInPixel);
        }
        {
            CharacterStringPropertyType theTransformationDimensionDescription;
            theTransformationDimensionDescription = this.getTransformationDimensionDescription();
            strategy.appendField(locator, this, "transformationDimensionDescription", buffer, theTransformationDimensionDescription);
        }
        {
            List<CharacterStringPropertyType> theTransformationDimensionMapping;
            theTransformationDimensionMapping = (((this.transformationDimensionMapping!= null)&&(!this.transformationDimensionMapping.isEmpty()))?this.getTransformationDimensionMapping():null);
            strategy.appendField(locator, this, "transformationDimensionMapping", buffer, theTransformationDimensionMapping);
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof MDGeorectifiedType)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final MDGeorectifiedType that = ((MDGeorectifiedType) object);
        {
            BooleanPropertyType lhsCheckPointAvailability;
            lhsCheckPointAvailability = this.getCheckPointAvailability();
            BooleanPropertyType rhsCheckPointAvailability;
            rhsCheckPointAvailability = that.getCheckPointAvailability();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "checkPointAvailability", lhsCheckPointAvailability), LocatorUtils.property(thatLocator, "checkPointAvailability", rhsCheckPointAvailability), lhsCheckPointAvailability, rhsCheckPointAvailability)) {
                return false;
            }
        }
        {
            CharacterStringPropertyType lhsCheckPointDescription;
            lhsCheckPointDescription = this.getCheckPointDescription();
            CharacterStringPropertyType rhsCheckPointDescription;
            rhsCheckPointDescription = that.getCheckPointDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "checkPointDescription", lhsCheckPointDescription), LocatorUtils.property(thatLocator, "checkPointDescription", rhsCheckPointDescription), lhsCheckPointDescription, rhsCheckPointDescription)) {
                return false;
            }
        }
        {
            List<GMPointPropertyType> lhsCornerPoints;
            lhsCornerPoints = (((this.cornerPoints!= null)&&(!this.cornerPoints.isEmpty()))?this.getCornerPoints():null);
            List<GMPointPropertyType> rhsCornerPoints;
            rhsCornerPoints = (((that.cornerPoints!= null)&&(!that.cornerPoints.isEmpty()))?that.getCornerPoints():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "cornerPoints", lhsCornerPoints), LocatorUtils.property(thatLocator, "cornerPoints", rhsCornerPoints), lhsCornerPoints, rhsCornerPoints)) {
                return false;
            }
        }
        {
            GMPointPropertyType lhsCenterPoint;
            lhsCenterPoint = this.getCenterPoint();
            GMPointPropertyType rhsCenterPoint;
            rhsCenterPoint = that.getCenterPoint();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "centerPoint", lhsCenterPoint), LocatorUtils.property(thatLocator, "centerPoint", rhsCenterPoint), lhsCenterPoint, rhsCenterPoint)) {
                return false;
            }
        }
        {
            MDPixelOrientationCodePropertyType lhsPointInPixel;
            lhsPointInPixel = this.getPointInPixel();
            MDPixelOrientationCodePropertyType rhsPointInPixel;
            rhsPointInPixel = that.getPointInPixel();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "pointInPixel", lhsPointInPixel), LocatorUtils.property(thatLocator, "pointInPixel", rhsPointInPixel), lhsPointInPixel, rhsPointInPixel)) {
                return false;
            }
        }
        {
            CharacterStringPropertyType lhsTransformationDimensionDescription;
            lhsTransformationDimensionDescription = this.getTransformationDimensionDescription();
            CharacterStringPropertyType rhsTransformationDimensionDescription;
            rhsTransformationDimensionDescription = that.getTransformationDimensionDescription();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "transformationDimensionDescription", lhsTransformationDimensionDescription), LocatorUtils.property(thatLocator, "transformationDimensionDescription", rhsTransformationDimensionDescription), lhsTransformationDimensionDescription, rhsTransformationDimensionDescription)) {
                return false;
            }
        }
        {
            List<CharacterStringPropertyType> lhsTransformationDimensionMapping;
            lhsTransformationDimensionMapping = (((this.transformationDimensionMapping!= null)&&(!this.transformationDimensionMapping.isEmpty()))?this.getTransformationDimensionMapping():null);
            List<CharacterStringPropertyType> rhsTransformationDimensionMapping;
            rhsTransformationDimensionMapping = (((that.transformationDimensionMapping!= null)&&(!that.transformationDimensionMapping.isEmpty()))?that.getTransformationDimensionMapping():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "transformationDimensionMapping", lhsTransformationDimensionMapping), LocatorUtils.property(thatLocator, "transformationDimensionMapping", rhsTransformationDimensionMapping), lhsTransformationDimensionMapping, rhsTransformationDimensionMapping)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            BooleanPropertyType theCheckPointAvailability;
            theCheckPointAvailability = this.getCheckPointAvailability();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "checkPointAvailability", theCheckPointAvailability), currentHashCode, theCheckPointAvailability);
        }
        {
            CharacterStringPropertyType theCheckPointDescription;
            theCheckPointDescription = this.getCheckPointDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "checkPointDescription", theCheckPointDescription), currentHashCode, theCheckPointDescription);
        }
        {
            List<GMPointPropertyType> theCornerPoints;
            theCornerPoints = (((this.cornerPoints!= null)&&(!this.cornerPoints.isEmpty()))?this.getCornerPoints():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "cornerPoints", theCornerPoints), currentHashCode, theCornerPoints);
        }
        {
            GMPointPropertyType theCenterPoint;
            theCenterPoint = this.getCenterPoint();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "centerPoint", theCenterPoint), currentHashCode, theCenterPoint);
        }
        {
            MDPixelOrientationCodePropertyType thePointInPixel;
            thePointInPixel = this.getPointInPixel();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "pointInPixel", thePointInPixel), currentHashCode, thePointInPixel);
        }
        {
            CharacterStringPropertyType theTransformationDimensionDescription;
            theTransformationDimensionDescription = this.getTransformationDimensionDescription();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "transformationDimensionDescription", theTransformationDimensionDescription), currentHashCode, theTransformationDimensionDescription);
        }
        {
            List<CharacterStringPropertyType> theTransformationDimensionMapping;
            theTransformationDimensionMapping = (((this.transformationDimensionMapping!= null)&&(!this.transformationDimensionMapping.isEmpty()))?this.getTransformationDimensionMapping():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "transformationDimensionMapping", theTransformationDimensionMapping), currentHashCode, theTransformationDimensionMapping);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        super.copyTo(locator, draftCopy, strategy);
        if (draftCopy instanceof MDGeorectifiedType) {
            final MDGeorectifiedType copy = ((MDGeorectifiedType) draftCopy);
            if (this.checkPointAvailability!= null) {
                BooleanPropertyType sourceCheckPointAvailability;
                sourceCheckPointAvailability = this.getCheckPointAvailability();
                BooleanPropertyType copyCheckPointAvailability = ((BooleanPropertyType) strategy.copy(LocatorUtils.property(locator, "checkPointAvailability", sourceCheckPointAvailability), sourceCheckPointAvailability));
                copy.setCheckPointAvailability(copyCheckPointAvailability);
            } else {
                copy.checkPointAvailability = null;
            }
            if (this.checkPointDescription!= null) {
                CharacterStringPropertyType sourceCheckPointDescription;
                sourceCheckPointDescription = this.getCheckPointDescription();
                CharacterStringPropertyType copyCheckPointDescription = ((CharacterStringPropertyType) strategy.copy(LocatorUtils.property(locator, "checkPointDescription", sourceCheckPointDescription), sourceCheckPointDescription));
                copy.setCheckPointDescription(copyCheckPointDescription);
            } else {
                copy.checkPointDescription = null;
            }
            if ((this.cornerPoints!= null)&&(!this.cornerPoints.isEmpty())) {
                List<GMPointPropertyType> sourceCornerPoints;
                sourceCornerPoints = (((this.cornerPoints!= null)&&(!this.cornerPoints.isEmpty()))?this.getCornerPoints():null);
                @SuppressWarnings("unchecked")
                List<GMPointPropertyType> copyCornerPoints = ((List<GMPointPropertyType> ) strategy.copy(LocatorUtils.property(locator, "cornerPoints", sourceCornerPoints), sourceCornerPoints));
                copy.cornerPoints = null;
                if (copyCornerPoints!= null) {
                    List<GMPointPropertyType> uniqueCornerPointsl = copy.getCornerPoints();
                    uniqueCornerPointsl.addAll(copyCornerPoints);
                }
            } else {
                copy.cornerPoints = null;
            }
            if (this.centerPoint!= null) {
                GMPointPropertyType sourceCenterPoint;
                sourceCenterPoint = this.getCenterPoint();
                GMPointPropertyType copyCenterPoint = ((GMPointPropertyType) strategy.copy(LocatorUtils.property(locator, "centerPoint", sourceCenterPoint), sourceCenterPoint));
                copy.setCenterPoint(copyCenterPoint);
            } else {
                copy.centerPoint = null;
            }
            if (this.pointInPixel!= null) {
                MDPixelOrientationCodePropertyType sourcePointInPixel;
                sourcePointInPixel = this.getPointInPixel();
                MDPixelOrientationCodePropertyType copyPointInPixel = ((MDPixelOrientationCodePropertyType) strategy.copy(LocatorUtils.property(locator, "pointInPixel", sourcePointInPixel), sourcePointInPixel));
                copy.setPointInPixel(copyPointInPixel);
            } else {
                copy.pointInPixel = null;
            }
            if (this.transformationDimensionDescription!= null) {
                CharacterStringPropertyType sourceTransformationDimensionDescription;
                sourceTransformationDimensionDescription = this.getTransformationDimensionDescription();
                CharacterStringPropertyType copyTransformationDimensionDescription = ((CharacterStringPropertyType) strategy.copy(LocatorUtils.property(locator, "transformationDimensionDescription", sourceTransformationDimensionDescription), sourceTransformationDimensionDescription));
                copy.setTransformationDimensionDescription(copyTransformationDimensionDescription);
            } else {
                copy.transformationDimensionDescription = null;
            }
            if ((this.transformationDimensionMapping!= null)&&(!this.transformationDimensionMapping.isEmpty())) {
                List<CharacterStringPropertyType> sourceTransformationDimensionMapping;
                sourceTransformationDimensionMapping = (((this.transformationDimensionMapping!= null)&&(!this.transformationDimensionMapping.isEmpty()))?this.getTransformationDimensionMapping():null);
                @SuppressWarnings("unchecked")
                List<CharacterStringPropertyType> copyTransformationDimensionMapping = ((List<CharacterStringPropertyType> ) strategy.copy(LocatorUtils.property(locator, "transformationDimensionMapping", sourceTransformationDimensionMapping), sourceTransformationDimensionMapping));
                copy.transformationDimensionMapping = null;
                if (copyTransformationDimensionMapping!= null) {
                    List<CharacterStringPropertyType> uniqueTransformationDimensionMappingl = copy.getTransformationDimensionMapping();
                    uniqueTransformationDimensionMappingl.addAll(copyTransformationDimensionMapping);
                }
            } else {
                copy.transformationDimensionMapping = null;
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new MDGeorectifiedType();
    }

}
